package core

import (
  "fmt"
)

type EachFn func (Value, bool) error
type MapFn func (Value) (Value, error)

func Next (c Value) (car Value, cdr Value, err error) {
	if c == nil {
		return nil, nil, fmt.Errorf("Not enough arguments")
	}
  switch c := c.(type) {
  case *Cons:
    return c.car, c.cdr, nil
  default:
    return c, nil, nil
  }
}

func Map (c Value, f MapFn) (res Value, err error) {
  switch c := c.(type) {
  case *Cons:
		var a, b Value
		a, ^err = f(c.car)
		b, ^err = Map(c.cdr, f)
		res = NewCons(a, b)
	case nil:
	default:
		res, ^err = f(c)
  }
  return
}

func Each (c Value, f EachFn) (err error) {
  switch c := c.(type) {
  case *Cons:
		^err = f(c.car, false)
		^err = Each(c.cdr, f)
	case nil:
	default:
		^err = f(c, true)
  }
  return
}

func ToArray (c Value) []Value {
  array := []Value{}
again:
  switch c2 := c.(type) {
  case *Cons:
    array = append(array, c2.car)
    c = c2.cdr
    goto again
	case nil:
	default:
    array = append(array, c2)
  }
  return array
}

func UnpackArgs (c Value, min, max int) (array []Value, err error) {
  array = []Value{}
again:
  switch c2 := c.(type) {
  case *Cons:
    array = append(array, c2.car)
    c = c2.cdr
    goto again
	case nil:
	default:
    array = append(array, c2)
  }
  if len(array) < min || (max >= 0 && len(array) > max) {
    if min == max {
      return nil, fmt.Errorf("expected %d arguments, got %d", min, len(array))
    } else if max == -1 {
      return nil, fmt.Errorf("expected at least %d arguments, got %d", min, len(array))
    } else {
      return nil, fmt.Errorf("expected %d to %d arguments, got %d", min, max, len(array))
    }
  }
  return array, nil
}
