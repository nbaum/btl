package core

import (
  "io"
  "fmt"
  "unicode"
  "strconv"
  "strings"
)

type Scanner struct {
  rs io.RuneScanner
}

func NewScanner (rs io.RuneScanner) *Scanner {
  return &Scanner{rs}
}

func (s *Scanner) get () (rune, error) {
  if r, _, err := s.rs.ReadRune(); err == io.EOF {
    return -1, nil
  } else if err == nil {
    return r, nil
  } else {
    return 0, err
  }
}

func (s *Scanner) peek () rune {
  if r, _, err := s.rs.ReadRune(); err != nil {
    return -1
  } else {
    s.unget()
    return r
  }
}

func (s *Scanner) unget () error {
  return s.rs.UnreadRune()
}

func (s *Scanner) chomp () (err error) {
  var r rune
again:
  if r, ^err = s.get(); unicode.IsSpace(r) {
    goto again
  } else if r != -1 {
    ^err = s.unget()
  }
  return
}

var dot = &Handle{}

func (s *Scanner) readString () (val Value, err error) {
  var r rune
  buff := ""
  for {
    r, ^err = s.get()
    switch r {
    case -1:
      return nil, io.EOF
    case '"':
      return Str(buff), nil
    case '\\':
      r, ^err = s.get()
      fallthrough
    default:
      buff += string(r)
    }
  }
}

func (s *Scanner) readList (end rune) (val *Cons, err error) {
  var r rune
  val = List(nil)
  val.car, ^err = s.ReadForm()
  tail := val
  for {
    ^err = s.chomp()
    r, ^err = s.get()
    switch r {
    case -1:
      ^err = io.EOF
    case end:
      return
    default:
      var item Value
      ^err = s.unget()
      item, ^err = s.ReadForm()
      if item == dot {
        if tail.cdr != nil {
          ^err = fmt.Errorf("two dotted pairs in a list")
        }
        tail.cdr, ^err = s.ReadForm()
      } else {
        tail.cdr = List(item)
        tail = tail.cdr.(*Cons)
      }
    }
  }
}

func (s *Scanner) readVector () (val *Vec, err error) {
  var r rune
  vec := Vec([]Value{})
  for {
    ^err = s.chomp()
    r, ^err = s.get()
    switch r {
    case -1:
      ^err = io.EOF
    case ')':
      return &vec, nil
    default:
      var item Value
      ^err = s.unget()
      item, ^err = s.ReadForm()
      vec = append(vec, item)
    }
  }
}

func (s *Scanner) isAtomRune (r rune) bool {
  return !strings.ContainsRune("()[]{}'`,;#\"", r) && !unicode.IsSpace(r)
}

func (s *Scanner) ReadForm () (val Value, err error) {
  var r rune
  ^err = s.chomp()
  r, ^err = s.get()
  switch r {
  case -1:
    return nil, io.EOF
  case '(':
    if s.peek() == ')' {
      s.get()
      return nil, nil
    } else {
      return s.readList(')')
    }
  case '[':
    if s.peek() == ']' {
      return List(Intern("fn"), List(Intern("_"))), nil
    } else {
      val, ^err = s.readList(']')
      return NewCons(Intern("fn"), NewCons(List(Intern("_")), val)), nil
    }
  case '`':
    val, ^err = s.ReadForm()
    return List(Intern("quasiquote"), val), nil
  case ',':
    if s.peek() == '@' {
      val, ^err = s.ReadForm()
      return List(Intern("unquote-splicing"), val), nil
    } else {
      val, ^err = s.ReadForm()
      return List(Intern("unquote"), val), nil
    }
  case '\'':
    val, ^err = s.ReadForm()
    return List(Intern("quote"), val), nil
  case '#':
    r, ^err = s.get()
    switch r {
    case '(':
      val, ^err = s.readVector()
    default:
      ^err = fmt.Errorf("#%c not handled yet", r)
    }
  case '"':
    return s.readString()
  case '.':
    if r2 := s.peek(); !s.isAtomRune(r2) {
      return dot, nil
    }
    fallthrough
  default:
    if !s.isAtomRune(r) {
      ^err = fmt.Errorf("unexpected `%c'", r)
      return
    }
    atom := string(r)
    for {
      if r, ^err = s.get(); s.isAtomRune(r) {
        atom += string(r)
      } else {
        ^err = s.unget()
        break
      }
    }
    return processAtom(atom), nil
  }
  return
}

func processAtom (atom string) (res Value) {
  if val, err := strconv.ParseInt(atom, 0, 64); err == nil {
    return Int(val)
  } else if val, err := strconv.ParseFloat(atom, 64); err == nil {
    return Float(val)
  } else {
    return Intern(atom)
  }
}
