package core

import (
  "io"
  "fmt"
  "unicode"
  "strings"
)

type Scanner struct {
  rs io.RuneScanner
}

func NewScanner (rs io.RuneScanner) *Scanner {
  return &Scanner{rs}
}

func (s *Scanner) get () (rune, error) {
  if r, _, err := s.rs.ReadRune(); err == io.EOF {
    return -1, nil
  } else if err == nil {
    return r, nil
  } else {
    return 0, err
  }
}

func (s *Scanner) peek () rune {
  if r, _, err := s.rs.ReadRune(); err != nil {
    return -1
  } else {
    s.unget()
    return r
  }
}

func (s *Scanner) unget () error {
  return s.rs.UnreadRune()
}

func (s *Scanner) chomp () (err error) {
  var r rune
again:
  if r, ^err = s.get(); unicode.IsSpace(r) {
    goto again
  } else if r != -1 {
    ^err = s.unget()
  }
  return
}

var dot = &Handle{}

func (s *Scanner) readList () (val *Cons, err error) {
  var r rune
  val = List(nil)
  val.car, ^err = s.ReadForm()
  tail := val
  for {
    ^err = s.chomp()
    r, ^err = s.get()
    switch r {
    case -1:
      ^err = io.EOF
    case ')':
      return
    default:
      var item Value
      ^err = s.unget()
      item, ^err = s.ReadForm()
      if item == dot {
        if tail.cdr != nil {
          ^err = fmt.Errorf("two dotted pairs in a list")
        }
        tail.cdr, ^err = s.ReadForm()
      } else {
        tail.cdr = List(item)
        tail = tail.cdr.(*Cons)
      }
    }
  }
}

func (s *Scanner) isAtomRune (r rune) bool {
  return !strings.ContainsRune("()'`,;#", r) && !unicode.IsSpace(r)
}

func (s *Scanner) ReadForm () (val Value, err error) {
  var r rune
  ^err = s.chomp()
  r, ^err = s.get()
  switch r {
  case -1:
    return nil, io.EOF
  case '(':
    if s.peek() == ')' {
      return nil, nil
    } else {
      return s.readList()
    }
  case '`':
    val, ^err = s.ReadForm()
    return List(Intern("quasiquote"), val), nil
  case ',':
    if s.peek() == '@' {
      val, ^err = s.ReadForm()
      return List(Intern("unquote-splicing"), val), nil
    } else {
      val, ^err = s.ReadForm()
      return List(Intern("unquote"), val), nil
    }
  case '\'':
    val, ^err = s.ReadForm()
    return List(Intern("quote"), val), nil
  case '#':
    ^err = fmt.Errorf("# not handled yet")
  case '.':
    if r2 := s.peek(); !s.isAtomRune(r2) {
      return dot, nil
    }
    fallthrough
  default:
    atom := string(r)
    for {
      if r, ^err = s.get(); s.isAtomRune(r) {
        atom += string(r)
      } else {
        ^err = s.unget()
        break
      }
    }
    return Intern(atom), nil
  }
  return
}
