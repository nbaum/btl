package core

import "fmt"



var _ = defaultEnv.LetFn("+", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 2, -1)
  a := vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        a = Int(aa + b)
      case Float:
        a = Float(Float(aa) + b)
      default:
        return nil, fmt.Errorf("incompatible types for +: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        a = Float(aa + Float(b))
      case Float:
        a = Float(aa + b)
      default:
        return nil, fmt.Errorf("incompatible types for +: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

var _ = defaultEnv.LetFn("-", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 2, -1)
  a := vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        a = Int(aa - b)
      case Float:
        a = Float(Float(aa) - b)
      default:
        return nil, fmt.Errorf("incompatible types for -: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        a = Float(aa - Float(b))
      case Float:
        a = Float(aa - b)
      default:
        return nil, fmt.Errorf("incompatible types for -: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

var _ = defaultEnv.LetFn("*", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 2, -1)
  a := vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        a = Int(aa * b)
      case Float:
        a = Float(Float(aa) * b)
      default:
        return nil, fmt.Errorf("incompatible types for *: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        a = Float(aa * Float(b))
      case Float:
        a = Float(aa * b)
      default:
        return nil, fmt.Errorf("incompatible types for *: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

var _ = defaultEnv.LetFn("/", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 2, -1)
  a := vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        a = Int(aa / b)
      case Float:
        a = Float(Float(aa) / b)
      default:
        return nil, fmt.Errorf("incompatible types for /: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        a = Float(aa / Float(b))
      case Float:
        a = Float(aa / b)
      default:
        return nil, fmt.Errorf("incompatible types for /: %T and %T", a, b)
      }
    }
  }
  return a, nil
})




var _ = defaultEnv.LetFn("<", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 1, -1)
  var a Value = vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        if (aa < b) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (Float(aa) < b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        if (aa < Float(b)) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (aa < b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

var _ = defaultEnv.LetFn(">", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 1, -1)
  var a Value = vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        if (aa > b) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (Float(aa) > b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        if (aa > Float(b)) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (aa > b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

var _ = defaultEnv.LetFn("==", func (env *Env, args Value) (res Value, err error) {
  var vec []Value
  vec, ^err = UnpackArgs(args, 1, -1)
  var a Value = vec[0]
  for _, b := range vec[1:] {
    switch aa := a.(type) {
    case Int:
      switch b := b.(type) {
      case Int:
        if (aa == b) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (Float(aa) == b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    case Float:
      switch b := b.(type) {
      case Int:
        if (aa == Float(b)) {
          a = b
        } else {
          return nil, nil
        }
      case Float:
        if (aa == b) {
          a = b
        } else {
          return nil, nil
        }
      default:
        return nil, fmt.Errorf("incompatible types for adddition: %T and %T", a, b)
      }
    }
  }
  return a, nil
})

