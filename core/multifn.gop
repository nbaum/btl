package core

import "fmt"

type Method struct {
  fn Value
  sig Value
}

func (m *Method) Match (values Value) bool {
  names := m.sig
	if sym, ok := names.(Sym); ok {
    return IsA(values, sym)
	} else if names, ok := names.(*Cons); ok {
		if values, ok := values.(*Cons); ok {
			for {
        if !IsA(values.car, names.car) {
          return false
        }
				if names.cdr == nil {
					if values.cdr != nil {
						return false
					}
					break
				} else if next, ok := names.cdr.(*Cons); ok {
					names = next
				} else if next, ok := names.cdr.(Sym); ok {
          if !IsA(values.cdr, next) {
            return false
          }
					break
				} else {
					return false
				}
				if values.cdr == nil {
					if names != nil {
						return false
					}
					break
				} else if next, ok := values.cdr.(*Cons); ok {
					values = next
				} else {
					return false
				}
			}
		} else {
			return false
		}
  } else if names != nil || values != nil {
		return false
	}
	return true
}

func (m *Method) Apply (e *Env, args Value) (res Value, err error) {
  return e.Apply(m.fn, args)
}

type MultiFn struct {
  methods []*Method
}

func (f *MultiFn) Type () Value {
  return Intern("multifn")
}

func (f *MultiFn) String () string {
  return fmt.Sprintf("#<multifn>")
}

func (f *MultiFn) Apply (e *Env, args Value) (res Value, err error) {
  for _, m := range f.methods {
    if m.Match(args) {
      if m.fn != nil {
        return m.Apply(e, args)
      }
      break
    }
  }
  return nil, fmt.Errorf("no method for argument list %s", args)
}
