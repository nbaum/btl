package golem

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"math"
	"math/rand"
	"net"
	"os"
	"os/exec"
	"runtime"
	"sync"
	"time"
)

func f_coerce(e *Env, args Value) (val Value, err error) {
	val, args = Next(args)
	typ, args := Next(args)
	switch val := val.(type) {
	case Str:
		if typ == Intern("sym") {
			return Intern(string(val)), nil
		} else if typ == Intern("cons") {
			a := []Value{}
			for _, r := range []Rune(string(val)) {
				a = append(a, r)
			}
			return List(a...), nil
		}
	case Int:
		if typ == Intern("char") {
			return Rune(val), nil
		} else if typ == Intern("int") {
			return val, nil
		}
	}
	return nil, fmt.Errorf("no coercion from %T to %s", val, typ)
}

func f_type(e *Env, args Value) (val Value, err error) {
	arg, rest := Next(args)
	if args == nil || rest != nil {
		return nil, fmt.Errorf("type: 1 argument expected")
	}
	if typed, ok := arg.(Typed); ok {
		val = typed.Type()
	} else if arg == nil {
		val = Intern("sym")
	} else {
		err = fmt.Errorf("untyped: %v %T", arg, arg)
	}
	return
}

func f_fn(e *Env, args Value) (val Value, err error) {
	params, forms := Next(args)
	val = NewFn(func(_ *Env, args Value) (val Value, err error) {
		e2 := NewEnv(e)
		e2.DestructuringBind(params, args)
		return Each(forms, func(form Value) (val Value, err error) {
			return Eval(e2, form)
		})
	})
	return
}

func f_if(e *Env, args Value) (val Value, err error) {
	var arg Value
	for args != nil {
		arg, args = Next(args)
		if args == nil {
			return Eval(e, arg)
		} else {
			val, ^err = Eval(e, arg)
			arg, args = Next(args)
			if val != nil {
				return Eval(e, arg)
			}
		}
	}
	return nil, nil
}

func f_quasiquote(e *Env, args Value) (val Value, err error) {
	var helper func(Value) (Value, error, bool)
	helper = func(arg Value) (val Value, err error, splice bool) {
		switch arg := arg.(type) {
		case *Cons:
			if arg.car == Intern("unquote") {
				val, ^err = Nth(arg, 1)
				val, err = Eval(e, val)
				return val, err, false
			} else if arg.car == Intern("quasiquote") {
				return arg, err, false
			} else if arg.car == Intern("unquote-splicing") {
				val, ^err = Nth(arg, 1)
				val, err = Eval(e, val)
				return val, err, true
			} else {
				var head, tail *Cons
				for arg != nil {
					val, ^err, splice = helper(arg.car)
					if tail == nil {
						if splice {
							if cons, ok := val.(*Cons); ok {
								head = cons
							} else {
								return nil, fmt.Errorf("unquote-splicing returned non-cons"), false
							}
						} else {
							head = &Cons{val, nil}
						}
						tail = head
					} else {
						if splice {
							tail.cdr = val
						} else {
							tail.cdr = &Cons{val, nil}
						}
					}
					tail = head.EndOfList()
					switch cdr := arg.cdr.(type) {
					case nil:
						arg = nil
					case *Cons:
						arg = cdr
					default:
						val, ^err, _ = helper(cdr)
						tail.cdr = val
						arg = nil
					}
				}
				return head, nil, false
			}
		default:
			return arg, nil, false
		}
	}
	arg, args := Next(args)
	val, ^err, _ = helper(arg)
	return
}

func f_quote(e *Env, args Value) (val Value, err error) {
	arg, rest := Next(args)
	if args == nil || rest != nil {
		return nil, fmt.Errorf("quote: 1 argument expected")
	}
	return arg, nil
}

func f_assign(e *Env, args Value) (val Value, err error) {
	var name, value Value
	for args != nil {
		name, args = Next(args)
		if sym, ok := name.(Sym); ok {
			value, args = Next(args)
			value, ^err = Eval(e, value)
			if !e.Set(string(sym), value) {
				e.Bind(string(sym), value)
			}
		} else {
			return nil, fmt.Errorf("assign to non-symbol: %v", name)
		}
	}
	return value, nil
}

func f_lt(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				if a >= b {
					return nil, nil
				}
			case Float:
				if Float(a) >= b {
					return nil, nil
				}
			}
		case Float:
			switch b := b.(type) {
			case Int:
				if a >= Float(b) {
					return nil, nil
				}
			case Float:
				if a >= b {
					return nil, nil
				}
			}
		}
		total = b
	}
	return total, nil
}

func f_gt(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				if a <= b {
					return nil, nil
				}
			case Float:
				if Float(a) <= b {
					return nil, nil
				}
			}
		case Float:
			switch b := b.(type) {
			case Int:
				if a <= Float(b) {
					return nil, nil
				}
			case Float:
				if a <= b {
					return nil, nil
				}
			}
		}
		total = b
	}
	return total, nil
}

func f_bound(e *Env, args Value) (val Value, err error) {
	name, args := Next(args)
	if name, ok := name.(Sym); ok {
		val, err = e.Get(string(name))
		if err == nil {
			return name, nil
		} else {
			return nil, nil
		}
	}
	return nil, fmt.Errorf("bound: sym expected, got %v", name)
}

func f_exact(e *Env, args Value) (val Value, err error) {
	val, args = Next(args)
	switch val.(type) {
	case Int:
		return val, nil
	case Float:
		return nil, nil
	default:
		return nil, fmt.Errorf("exact: number expected, got %v", val)
	}
}

func f_is(e *Env, args Value) (val Value, err error) {
	a, args := Next(args)
	b, args := Next(args)
	if a == b {
		return a, nil
	} else {
		return nil, nil
	}
}

func f_car(e *Env, args Value) (val Value, err error) {
	cons, args := Next(args)
	if cons, ok := cons.(*Cons); ok {
		return cons.car, nil
	}
	return nil, fmt.Errorf("car expects cons, got %v", cons)
}

func f_cdr(e *Env, args Value) (val Value, err error) {
	cons, args := Next(args)
	if cons, ok := cons.(*Cons); ok {
		return cons.cdr, nil
	}
	return nil, fmt.Errorf("car expects cons, got %v", cons)
}

func f_cons(e *Env, args Value) (val Value, err error) {
	car, args := Next(args)
	cdr, args := Next(args)
	return &Cons{car, cdr}, nil
}

func f_newstring(e *Env, args Value) (val Value, err error) {
	count, args := Next(args)
	char, args := Next(args)
	if c, ok := count.(Int); ok {
		if r, ok := char.(Rune); ok {
			s := ""
			for i := 0; i < int(c); i += 1 {
				s += string(r)
			}
			return Str(s), nil
		} else {
			return nil, fmt.Errorf("newstring: rune expected, got %v", char)
		}
	} else {
		return nil, fmt.Errorf("newstring: integer count expected, got %v", count)
	}
}

func f_scar(e *Env, args Value) (Value, error) {
	obj, args := Next(args)
	val, args := Next(args)
	if col, ok := obj.(Sliceable); ok {
		return val, col.SetCar(val)
	} else {
		return nil, fmt.Errorf("scar not supported on %v", obj)
	}
}

func f_scdr(e *Env, args Value) (Value, error) {
	obj, args := Next(args)
	val, args := Next(args)
	if col, ok := obj.(Sliceable); ok {
		return val, col.SetCdr(val)
	} else {
		return nil, fmt.Errorf("scar not supported on %v", obj)
	}
}

func f_sref(e *Env, args Value) (Value, error) {
	obj, args := Next(args)
	key, args := Next(args)
	val, args := Next(args)
	if col, ok := obj.(Collection); ok {
		return val, col.Set(key, val)
	} else {
		return nil, fmt.Errorf("sref not supported on %s", obj)
	}
}

func f_len(e *Env, args Value) (val Value, err error) {
	obj, args := Next(args)
	switch obj := obj.(type) {
	case *Cons:
		l := 0
		for obj != nil {
			switch cdr := obj.cdr.(type) {
			case *Cons:
				l += 1
				obj = cdr
			default:
				l += 1
				obj = nil
			}
		}
		return Int(l), nil
	case Str:
		return Int(len(obj)), nil
	case Sym:
		return Int(len(obj)), nil
	default:
		return nil, fmt.Errorf("length undefined for %v", obj)
	}
}

func f_mul(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				total = Int(a - b)
			case Float:
				total = Float(Float(a) - b)
			}
		case Float:
			switch b := b.(type) {
			case Int:
				total = Float(a - Float(b))
			case Float:
				total = Float(a - b)
			}
		}
	}
	return total, nil
}

func f_add(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				total = Int(a + b)
			case Float:
				total = Float(Float(a) + b)
			}
		case Float:
			switch b := b.(type) {
			case Int:
				total = Float(a + Float(b))
			case Float:
				total = Float(a + b)
			}
		case Str:
			switch b := b.(type) {
			case Str:
				total = Str(a + b)
			}
		case *Cons:
			switch b := b.(type) {
			case *Cons:
				a = a.Clone()
				a.EndOfList().cdr = b
				total = a
			}
		}
	}
	return total, nil
}

func f_sub(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				total = Int(a - b)
			case Float:
				total = Float(Float(a) - b)
			}
		case Float:
			switch b := b.(type) {
			case Int:
				total = Float(a - Float(b))
			case Float:
				total = Float(a - b)
			}
		}
	}
	return total, nil
}

func f_div(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				total = Int(a / b)
			case Float:
				total = Float(Float(a) / b)
			}
		case Float:
			switch b := b.(type) {
			case Int:
				total = Float(a / Float(b))
			case Float:
				total = Float(a / b)
			}
		}
	}
	return total, nil
}

func f_cos(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	switch arg := arg.(type) {
	case Int:
		return math.Cos(float64(arg)), nil
	case Float:
		return math.Cos(float64(arg)), nil
	}
	return nil, fmt.Errorf("cos undefined for %v", arg)
}

func f_expt(e *Env, args Value) (val Value, err error) {
	x, args := Next(args)
	y, args := Next(args)
	switch x := x.(type) {
	case Float:
		switch y := y.(type) {
		case Float:
			return Float(math.Pow(float64(x), float64(y))), nil
		case Int:
			return Float(math.Pow(float64(x), float64(y))), nil
		}
	case Int:
		switch y := y.(type) {
		case Float:
			return Float(math.Pow(float64(x), float64(y))), nil
		case Int:
			return Float(math.Pow(float64(x), float64(y))), nil
		}
	}
	return nil, fmt.Errorf("undefined: (expt %v %v)", x, y)
}

func f_log(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	switch arg := arg.(type) {
	case Int:
		return math.Log(float64(arg)), nil
	case Float:
		return math.Log(float64(arg)), nil
	}
	return nil, fmt.Errorf("log undefined for %v", arg)
}

func f_mod(e *Env, args Value) (val Value, err error) {
	var total, b Value
	total, args = Next(args)
	for args != nil {
		b, args = Next(args)
		switch a := total.(type) {
		case Int:
			switch b := b.(type) {
			case Int:
				total = Int(a % b)
			case Float:
				total = Float(math.Mod(float64(a), float64(b)))
			}
		case Float:
			switch b := b.(type) {
			case Int:
				total = Float(math.Mod(float64(a), float64(b)))
			case Float:
				total = Float(math.Mod(float64(a), float64(b)))
			}
		}
	}
	return total, nil
}

func f_rand(e *Env, args Value) (val Value, err error) {
	limit, args := Next(args)
	if i, ok := limit.(Int); ok {
		return Int(rand.Intn(int(i))), nil
	} else if limit == nil {
		return Float(rand.Float64()), nil
	}
	return nil, fmt.Errorf("rand: expected nil or int, got %v", limit)
}

func f_sin(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	switch arg := arg.(type) {
	case Int:
		return math.Sin(float64(arg)), nil
	case Float:
		return math.Sin(float64(arg)), nil
	}
	return nil, fmt.Errorf("sin undefined for %v", arg)
}

func f_sqrt(e *Env, args Value) (val Value, err error) {
	x, args := Next(args)
	switch x := x.(type) {
	case Float:
		return Float(math.Sqrt(float64(x))), nil
	case Int:
		return Float(math.Sqrt(float64(x))), nil
	default:
		return nil, fmt.Errorf("sqrt undefined for %v", x)
	}
}

func f_tan(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	switch arg := arg.(type) {
	case Int:
		return math.Tan(float64(arg)), nil
	case Float:
		return math.Tan(float64(arg)), nil
	}
	return nil, fmt.Errorf("tan undefined for %v", arg)
}

func f_trunc(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	switch arg := arg.(type) {
	case Int:
		return arg, nil
	case Float:
		return math.Floor(float64(arg)), nil
	}
	return nil, fmt.Errorf("trunc undefined for %v", arg)
}

func f_maptable(e *Env, args Value) (val Value, err error) {
	proc, args := Next(args)
	table, args := Next(args)
	if table, ok := table.(*Table); ok {
		for key, value := range *table {
			_, ^err = Apply(e, proc, List(key, value))
		}
		return table, nil
	}
	return nil, fmt.Errorf("maptable expects table, got %v", table)
}

func f_table(e *Env, args Value) (val Value, err error) {
	return NewTable(), nil
}

func f_eval(e *Env, args Value) (val Value, err error) {
	form, args := Next(args)
	return Eval(e, form)
}

func f_apply(e *Env, args Value) (val Value, err error) {
	proc, args := Next(args)
	pargs, args := Next(args)
	return Apply(e, proc, pargs)
}

func f_ssexpand(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: ssexpand")
}

func f_ssyntax(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: ssyntax")
}

func f_annotate(e *Env, args Value) (val Value, err error) {
	tag, args := Next(args)
	rep, args := Next(args)
	return &Tagged{tag, rep}, nil
}

func f_macex(e *Env, args Value) (val Value, err error) {
	var op Value
	form, args := Next(args)
again:
	if cons, ok := form.(*Cons); ok {
		op, ^err = Eval(e, cons.car)
		if op, ok := op.(*Tagged); ok {
			if op.tag == Intern("macro") {
				form, ^err = Apply(e, op.rep, cons.cdr)
				goto again
			}
		}
	}
	return form, nil
}

func f_macex1(e *Env, args Value) (val Value, err error) {
	var op Value
	form, args := Next(args)
	if form, ok := form.(*Cons); ok {
		op, ^err = Eval(e, form.car)
		if op, ok := op.(*Tagged); ok {
			if op.tag == Intern("macro") {
				return Apply(e, op.rep, form.cdr)
			}
		}
	}
	return form, nil
}

func f_rep(e *Env, args Value) (val Value, err error) {
	val, args = Next(args)
	if tag, ok := val.(*Tagged); ok {
		val = tag.rep
	}
	return
}

func f_sig(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: sig")
}

var uniqNum = 0

func f_uniq(e *Env, args Value) (val Value, err error) {
	uniqNum += 1
	return Intern(fmt.Sprintf("gs%d", uniqNum)), nil
}

func f_call_w_stdin(e *Env, args Value) (val Value, err error) {
	var oldPort Value
	port, args := Next(args)
	fn, args := Next(args)
	oldPort, ^err = e.Get("current-stdin")
	defer func() {
		e.Set("current-stdin", oldPort)
	}()
	e.Set("current-stdin", port)
	return Apply(e, fn, nil)
}

func f_call_w_stdout(e *Env, args Value) (val Value, err error) {
	var oldPort Value
	port, args := Next(args)
	fn, args := Next(args)
	oldPort, ^err = e.Get("current-stdout")
	defer func() {
		e.Set("current-stdout", oldPort)
	}()
	e.Set("current-stdout", port)
	return Apply(e, fn, nil)
}

func f_close(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: close")
}

func f_force_close(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: force-close")
}

func f_disp(e *Env, args Value) (val Value, err error) {
	obj, args := Next(args)
	if disper, ok := obj.(Disper); ok {
		^err = disper.Disp(e)
	} else {
		fmt.Printf("%s", obj)
	}
	return obj, nil
}

func f_peekc(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*InPort); ok {
		var r rune
		r, _, ^err = port.ReadRune()
		return Rune(r), nil
	} else {
		return nil, fmt.Errorf("unimplemented: peekc")
	}
}

func f_flushout(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: flushout")
}

func f_pipe_from(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	// nargs := []string{}
	// for args != nil {
	// 	arg, args = Next(args)
	// 	if arg, ok := arg.(Str); ok {
	// 		nargs = append(nargs, string(arg))
	// 	} else {
	// 		return nil, fmt.Errorf("unimplemented: pipe-from")
	// 	}
	// }
	if arg, ok := arg.(Str); ok {
		cmd := exec.Command("/bin/sh", "-c", string(arg))
		var pipe io.ReadCloser
		pipe, ^err = cmd.StdoutPipe()
		^err = cmd.Start()
		return NewInPort(bufio.NewReader(pipe)), nil
	}
	return nil, fmt.Errorf("pipe-from expects string, got %v", arg)
}

func f_readb(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*InPort); ok {
		var b byte
		b, ^err = port.ReadByte()
		return Int(b), nil
	} else {
		return nil, fmt.Errorf("unimplemented: readb")
	}
}

func f_readc(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*InPort); ok {
		var r rune
		r, _, ^err = port.ReadRune()
		return Rune(r), nil
	} else {
		return nil, fmt.Errorf("unimplemented: readc")
	}
}

func f_sread(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*InPort); ok {
		return NewScanner(port).ReadForm()
	} else {
		return nil, fmt.Errorf("unimplemented: readc")
	}
}

func f_stderr(e *Env, args Value) (val Value, err error) {
	return NewOutPort(bufio.NewWriter(os.Stderr)), nil
}

func f_stdin(e *Env, args Value) (val Value, err error) {
	return NewInPort(bufio.NewReader(os.Stdin)), nil
}

func f_stdout(e *Env, args Value) (val Value, err error) {
	return NewOutPort(bufio.NewWriter(os.Stdout)), nil
}

func f_write(e *Env, args Value) (val Value, err error) {
	obj, args := Next(args)
	port, args := Next(args)
	if port == nil {
		port, ^err = e.Get("current-stdout")
	}
	if port, ok := port.(*OutPort); ok {
		fmt.Fprint(port, obj)
		return obj, nil
	} else {
		return obj, fmt.Errorf("not an outport: %v", port)
	}
}

func f_writeb(e *Env, args Value) (val Value, err error) {
	b, args := Next(args)
	port, args := Next(args)
	if port == nil {
		port, ^err = e.Get("current-stdout")
	}
	if b, ok := b.(Int); ok {
		if port, ok := port.(*OutPort); ok {
			^err = port.WriteByte(byte(b))
			return b, nil
		}
	}
	return nil, fmt.Errorf("unimplemented: writeb")
}

func f_writec(e *Env, args Value) (val Value, err error) {
	r, args := Next(args)
	port, args := Next(args)
	if port == nil {
		port, ^err = e.Get("current-stdout")
	}
	if r, ok := r.(Rune); ok {
		if port, ok := port.(*OutPort); ok {
			_, ^err = port.WriteRune(rune(r))
			return r, nil
		}
	}
	return nil, fmt.Errorf("unimplemented: writec")
}

func f_inside(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*OutPort); ok {
		if buffer, ok := port.RuneWriter.(*bytes.Buffer); ok {
			return Str(buffer.String()), nil
		}
	}
	return nil, fmt.Errorf("unimplemented: inside")
}

func f_instring(e *Env, args Value) (val Value, err error) {
	str, args := Next(args)
	if str, ok := str.(Str); ok {
		b := bytes.NewBufferString(string(str))
		return NewInPort(b), nil
	}
	return nil, fmt.Errorf("instring expected string, got %v", str)
}

func f_outstring(e *Env, args Value) (val Value, err error) {
	b := new(bytes.Buffer)
	return NewOutPort(b), nil
}

func f_client_ip(e *Env, args Value) (val Value, err error) {
	port, args := Next(args)
	if port, ok := port.(*NetPort); ok {
		return fmt.Sprint(port.RemoteAddr()), nil
	}
	return nil, fmt.Errorf("unimplemented: client-ip")
}

func f_open_socket(e *Env, args Value) (val Value, err error) {
	var ln net.Listener
	port, args := Next(args)
	ln, ^err = net.Listen("tcp", fmt.Sprintf(":%v", port))
	return &Listener{ln}, nil
}

func f_socket_accept(e *Env, args Value) (val Value, err error) {
	ln, args := Next(args)
	if ln, ok := ln.(*Listener); ok {
		var conn net.Conn
		conn, ^err = ln.ln.Accept()
		port := NewNetPort(conn)
		return List(port, port), nil
	}
	return nil, fmt.Errorf("socket-accept expected listener, got %v", ln)
}

func f_dir(e *Env, args Value) (val Value, err error) {
	dir, args := Next(args)
	if dir, ok := dir.(Str); ok {
		var files []os.FileInfo
		files, ^err = ioutil.ReadDir(string(dir))
		names := []Value{}
		for _, file := range files {
			names = append(names, Str(file.Name()))
		}
		return List(names...), nil
	}
	return nil, fmt.Errorf("unimplemented: dir")
}

func f_dir_exists(e *Env, args Value) (val Value, err error) {
	dir, args := Next(args)
	if dir, ok := dir.(Str); ok {
		var file os.FileInfo
		file, err = os.Stat(string(dir))
		if err != nil {
			return nil, nil
		} else if file.IsDir() {
			return dir, nil
		} else {
			return nil, nil
		}
	}
	return nil, fmt.Errorf("unimplemented: dir")
}

func f_file_exists(e *Env, args Value) (val Value, err error) {
	dir, args := Next(args)
	if dir, ok := dir.(Str); ok {
		var file os.FileInfo
		file, err = os.Stat(string(dir))
		if err != nil {
			return nil, nil
		} else if !file.IsDir() {
			return dir, nil
		} else {
			return nil, nil
		}
	}
	return nil, fmt.Errorf("unimplemented: file-exists")
}

func f_infile(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: infile")
}

func f_outfile(e *Env, args Value) (val Value, err error) {
	name, args := Next(args)
	mode, args := Next(args)
	if name, ok := name.(Str); ok {
		var file *os.File
		if mode == Intern("append") {
			file, ^err = os.OpenFile(string(name), os.O_CREATE|os.O_RDWR|os.O_APPEND, 0666)
		} else {
			file, ^err = os.Create(string(name))
		}
		return NewOutPort(bufio.NewWriter(file)), nil
	}
	return nil, fmt.Errorf("unexpected filename, not %v", name)
}

func f_mvfile(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: mvfile")
}

func f_rmfile(e *Env, args Value) (val Value, err error) {
	name, args := Next(args)
	if name, ok := name.(Str); ok {
		^err = os.Remove(string(name))
		return name, nil
	}
	return nil, fmt.Errorf("unexpected filename, not %v", name)
}

var mutex = new(sync.Mutex)

func f_atomic_invoke(e *Env, args Value) (val Value, err error) {
	fn, args := Next(args)
	mutex.Lock()
	defer mutex.Unlock()
	return Apply(e, fn, nil)
}

func f_break_thread(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: break-thread")
}

func f_join_thread(e *Env, args Value) (val Value, err error) {
	thread, args := Next(args)
	if thread, ok := thread.(*Thread); ok {
		return thread.Wait()
	}
	return nil, fmt.Errorf("unimplemented: dead")
}

func f_dead(e *Env, args Value) (val Value, err error) {
	thread, args := Next(args)
	if thread, ok := thread.(*Thread); ok {
		if thread.dead {
			return thread, nil
		} else {
			return nil, nil
		}
	}
	return nil, fmt.Errorf("unimplemented: dead")
}

func f_kill_thread(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: kill-thread")
}

func f_new_thread(e *Env, args Value) (val Value, err error) {
	fn, args := Next(args)
	thread := NewThread(func(t Value) (Value, error) {
		return Apply(e, fn, List(t))
	})
	return thread, nil
}

func f_sleep(e *Env, args Value) (val Value, err error) {
	sleep, args := Next(args)
	switch sleep := sleep.(type) {
	case Int:
		time.Sleep(time.Duration(sleep) * time.Second)
		return nil, nil
	case Float:
		time.Sleep(time.Duration(float64(sleep) * float64(time.Second)))
		return nil, nil
	}
	return nil, fmt.Errorf("sleep expects number, got %v", sleep)
}

func f_details(e *Env, args Value) (val Value, err error) {
	err1, args := Next(args)
	if err1, ok := err1.(*Error); ok {
		return Str(err1.err.Error()), nil
	}
	return nil, fmt.Errorf("details expects error, got %v", err1)
}

func f_err(e *Env, args Value) (val Value, err error) {
	msg, args := Next(args)
	return nil, fmt.Errorf("%v", msg)
}

func DeferToErr(fn func() (Value, error)) (val Value, err error) {
	defer func() {
		if x := recover(); x != nil {
			if ee, ok := x.(error); ok {
				^err = ee
			} else {
				^err = fmt.Errorf("%v", x)
			}
		}
	}()
	return fn()
}

func f_on_err(e *Env, args Value) (val Value, err error) {
	handle, args := Next(args)
	try, args := Next(args)
	val, err = DeferToErr(func() (Value, error) {
		return Apply(e, try, nil)
	})
	if err != nil {
		if handle == nil {
			return nil, nil
		} else {
			val, ^err = Apply(e, handle, List(&Error{err}))
		}
	}
	return
}

func f_ccc(e *Env, args Value) (val Value, err error) {
	fn, args := Next(args)
	var t *Thread
	t = NewThread(func(Value) (Value, error) {
		return DeferToErr(func() (Value, error) {
			var hatch = func(e *Env, args Value) (Value, error) {
				val, args = Next(args)
				t.Finish(val, nil)
				runtime.Goexit()
				panic("unreachable")
			}
			return Apply(e, fn, List(NewFn(hatch)))
		})
	})
	return t.Wait()
}

func f_protect(e *Env, args Value) (val Value, err error) {
	fn, args := Next(args)
	after, args := Next(args)
	defer func() {
		Apply(e, after, nil)
	}()
	return Apply(e, fn, nil)
}

func f_current_gc_milliseconds(e *Env, args Value) (val Value, err error) {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	i := m.PauseTotalNs / 1000000
	return Int(i), nil
}

var startedAt = time.Now()

func f_current_process_milliseconds(e *Env, args Value) (val Value, err error) {
	return Int(time.Now().Sub(startedAt) / 1000000), nil
}

func f_msec(e *Env, args Value) (val Value, err error) {
	return Int(time.Now().UnixNano() / 1000000), nil
}

func f_seconds(e *Env, args Value) (val Value, err error) {
	return Int(time.Now().Unix()), nil
}

func f_timedate(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	var i int64
	if arg, ok := arg.(Int); ok {
		i = int64(arg)
	}
	t := time.Unix(i, 0)
	return List(t.Second(), t.Minute(), t.Hour(), t.Day(), t.Month(), t.Year()), nil
}

func f_declare(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: declare")
}

func f_memory(e *Env, args Value) (val Value, err error) {
	return nil, fmt.Errorf("unimplemented: memory")
}

func f_system(e *Env, args Value) (val Value, err error) {
	arg, args := Next(args)
	// nargs := []string{}
	// for args != nil {
	// 	arg, args = Next(args)
	// 	if arg, ok := arg.(Str); ok {
	// 		nargs = append(nargs, string(arg))
	// 	} else {
	// 		return nil, fmt.Errorf("unimplemented: pipe-from")
	// 	}
	// }
	if arg, ok := arg.(Str); ok {
		cmd := exec.Command("sh", "-c", string(arg))
		^err = cmd.Run()
		return nil, nil
	}
	return nil, fmt.Errorf("pipe-from expects string, got %v", arg)
}

func f_quit(e *Env, args Value) (val Value, err error) {
	os.Exit(0)
	panic("unreachable")
}

func (e *Env) Arclike() *Env {
	e.Bind("nil", nil)
	e.Bind("t", Intern("t"))
	e.Bind("+inf.0", Float(math.Inf(1)))
	e.Bind("-inf.0", Float(math.Inf(-1)))
	e.Bind("coerce", NewFn(f_coerce))
	e.Bind("type", NewFn(f_type))
	e.Bind("fn", Tag("special", NewFn(f_fn)))
	e.Bind("if", Tag("special", NewFn(f_if)))
	e.Bind("quasiquote", Tag("special", NewFn(f_quasiquote)))
	e.Bind("quote", Tag("special", NewFn(f_quote)))
	e.Bind("assign", Tag("special", NewFn(f_assign)))
	e.Bind("<", NewFn(f_lt))
	e.Bind(">", NewFn(f_gt))
	e.Bind("bound", NewFn(f_bound))
	e.Bind("exact", NewFn(f_exact))
	e.Bind("is", NewFn(f_is))
	e.Bind("car", NewFn(f_car))
	e.Bind("cdr", NewFn(f_cdr))
	e.Bind("cons", NewFn(f_cons))
	e.Bind("newstring", NewFn(f_newstring))
	e.Bind("scar", NewFn(f_scar))
	e.Bind("scdr", NewFn(f_scdr))
	e.Bind("sref", NewFn(f_sref))
	e.Bind("len", NewFn(f_len))
	e.Bind("*", NewFn(f_mul))
	e.Bind("+", NewFn(f_add))
	e.Bind("-", NewFn(f_sub))
	e.Bind("/", NewFn(f_div))
	e.Bind("cos", NewFn(f_cos))
	e.Bind("expt", NewFn(f_expt))
	e.Bind("log", NewFn(f_log))
	e.Bind("mod", NewFn(f_mod))
	e.Bind("rand", NewFn(f_rand))
	e.Bind("sin", NewFn(f_sin))
	e.Bind("sqrt", NewFn(f_sqrt))
	e.Bind("tan", NewFn(f_tan))
	e.Bind("trunc", NewFn(f_trunc))
	e.Bind("maptable", NewFn(f_maptable))
	e.Bind("table", NewFn(f_table))
	e.Bind("eval", NewFn(f_eval))
	e.Bind("apply", NewFn(f_apply))
	e.Bind("ssexpand", NewFn(f_ssexpand))
	e.Bind("ssyntax", NewFn(f_ssyntax))
	e.Bind("annotate", NewFn(f_annotate))
	e.Bind("macex", NewFn(f_macex))
	e.Bind("macex1", NewFn(f_macex1))
	e.Bind("rep", NewFn(f_rep))
	e.Bind("sig", NewFn(f_sig))
	e.Bind("uniq", NewFn(f_uniq))
	e.Bind("call-w/stdin", NewFn(f_call_w_stdin))
	e.Bind("call-w/stdout", NewFn(f_call_w_stdout))
	e.Bind("close", NewFn(f_close))
	e.Bind("force-close", NewFn(f_force_close))
	e.Bind("disp", NewFn(f_disp))
	e.Bind("peekc", NewFn(f_peekc))
	e.Bind("flushout", NewFn(f_flushout))
	e.Bind("pipe-from", NewFn(f_pipe_from))
	e.Bind("readb", NewFn(f_readb))
	e.Bind("readc", NewFn(f_readc))
	e.Bind("sread", NewFn(f_sread))
	e.Bind("stderr", NewFn(f_stderr))
	e.Bind("stdin", NewFn(f_stdin))
	e.Bind("stdout", NewFn(f_stdout))
	e.Bind("write", NewFn(f_write))
	e.Bind("writeb", NewFn(f_writeb))
	e.Bind("writec", NewFn(f_writec))
	e.Bind("inside", NewFn(f_inside))
	e.Bind("instring", NewFn(f_instring))
	e.Bind("outstring", NewFn(f_outstring))
	e.Bind("client-ip", NewFn(f_client_ip))
	e.Bind("open-socket", NewFn(f_open_socket))
	e.Bind("socket-accept", NewFn(f_socket_accept))
	e.Bind("dir", NewFn(f_dir))
	e.Bind("dir-exists", NewFn(f_dir_exists))
	e.Bind("file-exists", NewFn(f_file_exists))
	e.Bind("infile", NewFn(f_infile))
	e.Bind("outfile", NewFn(f_outfile))
	e.Bind("mvfile", NewFn(f_mvfile))
	e.Bind("rmfile", NewFn(f_rmfile))
	e.Bind("atomic-invoke", NewFn(f_atomic_invoke))
	e.Bind("break-thread", NewFn(f_break_thread))
	e.Bind("join-thread", NewFn(f_join_thread))
	e.Bind("dead", NewFn(f_dead))
	e.Bind("kill-thread", NewFn(f_kill_thread))
	e.Bind("new-thread", NewFn(f_new_thread))
	e.Bind("sleep", NewFn(f_sleep))
	e.Bind("details", NewFn(f_details))
	e.Bind("err", NewFn(f_err))
	e.Bind("on-err", NewFn(f_on_err))
	e.Bind("ccc", NewFn(f_ccc))
	e.Bind("protect", NewFn(f_protect))
	e.Bind("current-gc-milliseconds", NewFn(f_current_gc_milliseconds))
	e.Bind("current-process-milliseconds", NewFn(f_current_process_milliseconds))
	e.Bind("msec", NewFn(f_msec))
	e.Bind("seconds", NewFn(f_seconds))
	e.Bind("timedate", NewFn(f_timedate))
	e.Bind("declare", NewFn(f_declare))
	e.Bind("memory", NewFn(f_memory))
	e.Bind("system", NewFn(f_system))
	e.Bind("quit", NewFn(f_quit))
	return e
}
