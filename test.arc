42
5.0
;2.0-3.0i
+inf.0
(+ #x10 #d10 #o10 #b10)
;1/2+3/4i
1e3
;1/2e3
(type 5.0)
;(type 1+2i)
(prn #\a #\102 #\newline #\null #\u5a #\u4e9c #\U12031 #\日)
(type #\a)
(prn "a \102 \n \x00 \x5a \U4e9c 日")
(type "a")
'a
'b
(type 'c)
'(1 2 3)
(type '(1))
(fn (x) (+ x 1))
(def foo (x) (+ x 1))
(type (fn (x) (+ x 1)))
(mac bar (x) `(+ ,x 1))
(type (mac baz (x) `(+ ,x 1)))
(annotate 'mytype 'x)
(type (annotate 'mytype 'x))
(table)
(let x (table)
    (= (x 'key) 'value)
    (x 'key))
(type (table))
(type (stdin))
(type (outfile "/tmp/junk"))
(on-err (fn (ex) (prn ex) (prn (details ex)) (type ex))
    (fn () (car 1)))
(type (open-socket 8080))
(type (new-thread (fn x)))
(is nil '())
(type nil)
(no t)
(type t)
(coerce "a" 'sym)
(coerce 65 'char)
(coerce 65 'int 2)
(coerce "abc" 'cons)
(type 1)
(type car)
((fn (x y) (+ x y)) 1 2)
((fn all (len all)) 1 2 3)
((fn (arg1 arg2 . rest) rest) 1 2 3 4)
(if nil "Nil is true"
    0   "0 is true"
    "What is true?")
`((+ 1 2) ,(+ 3 4) ,@(list 5 6))
'(1 2 3)
(assign x 10)
(sqrt 2)
('(a b c) 1)
(let tbl (table)
  (= (tbl 3) 9)
  (= (tbl 4) 16)
  (tbl 3))
("abc" 1)
(< 1 2)
(< 1 2 3)
(< 1 3 2)
(< "a" "b")
(< 'a 'b)
(< #\a #\b)
(> 1 2)
(> 3 1 2)
(> "a" "b")
(> 'a 'b)
(> #\a #\b)
(bound 'foobar)
(do
       (assign y 1)
       (bound 'y))
(exact 3)
(exact 3.14)
(is 1 2)
(is "a" "a")
(is '(1) '(1))
(is 1 1 1 1)
(is nil '())
(car '(1 2 3))
(cdr '(1 2 3))
(cons 1 '(2 3))
(newstring 5 #\a)
;(do
;    (= x "abc")
;    (scar x #\d)
;    x)
(do
    (= x '(1 2 3))
    (scar x #\d)
    x)
(do
    (= x '(1 2 3))
    (scdr x #\d)
    x)
(do
    (= x '(1 2 3))
    (sref x 1 #\d) x)
(len "abc")
(len '(1 2 3))
(* 2 3)
(+ 1 2 3)
(+ "ab" "c" "de")
(+ '(1 2) '(3 4) '(5))
(- 3 2)
(/ 1 2)
(/ 1.0 2)
(cos 3.14)
(expt 2 3)
(log 100)
(mod 10 3)
(mod -10 3)
(rand 10)
(rand)
(sin 3.14)
(sqrt 2)
(sqrt -1)
(tan 3.14)
(trunc 1.9)
(trunc -1.1)
(let x (table)
    (sref x 9 3)
    (sref x 16 4)
    (maptable (fn (key val) (prn key " " val)) x))
(table)
(eval '(+ 1 2))
(apply + '(1 2))
;(ssexpand 'x:~y:z)
;(ssexpand '+.1.2)
;(ssexpand '+!1!2)
;(ssexpand 'cons!a!b)
;(ssyntax 'x:y)
(type (annotate 'mac car))
(macex '(let a 1 (pr a)))
(macex1 '(let a 1 (pr a)))
(rep whilet)
;(sig 'map)
(uniq)
(let sop (outstring)
  (call-w/stdout sop (fn () (prn '(1 2))))
  (inside sop))
(disp '(1 2))
(disp "abc")
(peekc (pipe-from "echo hello"))
(readline (pipe-from "echo hello"))
(readb (pipe-from "echo hello"))
(readc (pipe-from "echo ©"))
(sread (pipe-from "echo '(1 2) (3)'") "junk")
(stderr)
(stdin)
(stdout)
(write "abc")
(writeb 65)
(writec #\日)
(let sop (outstring) (write "hello" sop) (inside sop))
(readline (instring "hello"))
(outstring)
(let s (socket-accept (open-socket 8001))
    (client-ip (s 1)))
(open-socket 8002)
(socket-accept (open-socket 8003))
(dir "/")
(dir-exists "mydir")
(file-exists "mydir")
(outfile "/tmp/junk" 'append)
(outfile "/tmp/junk" 'append)
(rmfile "/tmp/junk")
(atomic-invoke (fn () "critical section" (+ 1 2)))
;(let th (new-thread (fn () (sleep 2)))
;  (break-thread th))
;(let th (new-thread (fn () (sleep 1)))
;  (prn (dead th)) (sleep 2) (prn (dead th)))
;(let th (new-thread (fn () (sleep 100)))
;    (kill-thread th)
;    (dead th))
(new-thread (fn () (+ 1 2)))
(dead (new-thread (fn () (+ 1 2))))
(join-thread (new-thread (fn () (+ 1 2))))
(sleep 0.1)
(on-err (fn (ex) (details ex)) (fn () (err "boo")))
;(err "Failure" 42)
(on-err (fn (ex) (prn "caught " (details ex)))
          (fn () (/ 1 0)))
(ccc (fn (ep) (ep "bailout value") 42))
(on-err
  nil
  (fn ()
    (protect (fn () (/ 1 0))
      (fn () (prn "after")))))
(current-gc-milliseconds)
(current-process-milliseconds)
(msec)
(seconds)
(system "date #/t")
(quit)
